<h1>Manual</h1>
<h3>Key features</h3>
<div class='alert alert-neutral'>
	<ul>
		<li>Easy and comfortable to use</li>
		<li>Accessible from anywhere via Web</li>
		<li>Server part highly compatible with common web hosting set-ups</li>
		<li>Agent part completely unattended</li>
		<li>File management for word lists, rules, ...</li>
		<li>Self-updating of both Hashtopussy and Hashcat</li>
		<li>Cracking multiple hashlists of the same type as one</li>
		<li>Running the same binary on Windows and Linux (OSX untested)</li>
		<li>Files/hashes marked as "secret" only distributed to agents marked as "trusted"</li>
		<li>Many options to import/export data</li>
		<li>A lot of statistic info about tasks/hashes</li>
		<li>Visual representation of chunk distribution</li>
		<li>Waiting for idle (Windows only)</li>
		<li>Event-driven cracking mode</li>
		<li>Multi-User Support</li>
		<li>User Permission levels</li>
	</ul>
</div>
<h3>Hashtopus or Hashtopussy?</h3>
<div class='alert alert-neutral'>
	Hashtopus is a great program but lacking in some areas major differences between the two are:
        <br>
	<ul>
		<li>Drastically Improved Security</li>
		<li>Multi User support</li>
		<li>Improved look and layout</li>
		<li>Super Tasks (hcmask support)</li>
		<li>Hex salt support</li>
	</ul>
</div>
<h3>Architecture concept</h3>
<div class='alert alert-neutral'>
	Hashtopussy is a multi platform client-server tool to distribute oclHashcat/cudaHashcat tasks between multiple computers and is strongly based on Hashtopus.
	<br>
	Like Hashtopus The main goals for its development were portability, robustness, Multi-user support, and to bring Hashtopus to the next level. 
	<br>
	The application has two parts:
	<ul>
		<li><b>Agent</b> single .NET 2.0 binary executable
		<br></li>
		<li><b>Server</b> several PHP/CSS files operating on two endpoints: Admin
			Gui and Agent Connection Point</li>
	</ul>
	While developed in C#.NET, the code is being programmed with Linux systems in mind as well, achieving full binary compatibility under Mono for .NET 2.0.
	<br>
	Aiming for high usability even on restricted networks, Hashtopussy communicates over HTTP(S) using own proprietary protocol (however easy to understand and text-readable).
	<br>
	 If you have proxy server configured in your system, Hashtopussy will use it, as per standard .NET feature.
</div>
<h3>Usage concept</h3>
<div class='alert alert-neutral'>
	The server part runs on PHP using MySQL as database back end. It is vital that your <b>MySQL server is configured as well as possible</b> performance wise. 
	<br>
 	Some of the queries can be very expensive and proper configuration makes the difference between few milliseconds of waiting and	disaster multi-second lags.
	<br>
	 The database schema heavily profits from indexing. Therefore, if you see a hint about pre-sorting your hashlist, please do so.
	<br>
	The web admin is therefore the single point of access once your agents were deployed on the cracking machines.
	<br>
	 New agent deployment requires one-time password generated in the admin, which protects your server from hashes/files leaking to rogue or fake agents.
</div>
<h3>Terminology</h3>
<div class='alert alert-neutral'>
	In this manual and in the Hashtopussy itself, I use several terms. So let's make them clear:
	<ul>
	<b>Agent:</b> A computer running Hashtopussy.exe and Hashcat doing the cracking itself.
	<br>
	<b>Hashlist:</b> A list of hashes saved in the database. Hashlist can be text, HCCAP or binary with most hashlists being the first category.
	<br>
	<b>Task:</b> A specific attack. Every task has a command line defining how will Hashcat be executed. Files can be assigned to a task (word lists, rules,...).
	<br>
	<b>Key space:</b> Every task has a predefined key space which says precisely how big set of keys will be searched.
	<br>
	<b>Chunk:</b> A chunk is a part of a key-space assigned to a specific agent. If a chunk times out, it (or its part) will be reassigned to next free agent.
	</ul>
</div>
<hr>
<h1>First steps</h1>
<h3>Prerequisites</h3>
<div class='alert alert-neutral'>
	<b>Server</b><br>
	<ul>
		<li>Web server (Apache 2 recommended)</li>
		<li>PHP module (PHP 5.3+) with r/w access for the web directory</li>
		<li>php5-mcrypt</li>
		<li>MySQL 5.x with r/w access for the web directory</li>
		<li>MySQL user with all privileges for used database and global FILE privilege</li>
	</ul><br>
	<b>Agent</b><br>
	<ul>
		<li><b>.NET 2.0 compatible environment (MS .NET 2.0 or Mono 2.0)</b> On
		debian-based systems, use</li>
		<li>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
		echo "deb http://download.mono-project.com/repo/debian wheezy main" </li> 
		<li>sudo tee /etc/apt/sources.list.d/mono-xamarin.list</li>
		<li>sudo apt-get update</li>
		<li><b>apt-get install mono-complete ca-certificates-mono</b> to install desired runtime
		environment.</li>
		<li><b>Sufficient GPU drivers (see Hashcat website)</b></li>
		<li><b>HTTPS connectivity to server</b></li>
	</ul>
</div>
<h3>Installation</h3>
<div class='alert alert-neutral'>
	If you meet all prerequisites, let's start with server installation.
	<li>Unpack the entire installation package to your web-accessible directory.</li>
	<li>Create a MySQL database and a MySQL user.</li>
	<li>Assign this user all access rights to the new database and a global FILE privilege. <b>(This is very
	important for ability to import and export hashes.)</b></li>
	<li>Doing just that, the environment should be ready to use.</li> 
	<li>Now open your web-root from a web browser.</li>
	<li>Follow the install script</li>
</div>
<h3>Initial configuration</h3>
<div class='alert alert-neutral'>
	Adjust the configuration variables to your need:
	<ul>
		<li>agenttimeout - How long will agent ask for work if there was
			none last time</li>
		<li>bench time - How long should benchmarking each agent take
			(seconds)</li>
		<li>chunk time - Default chunk time (read below) (seconds)</li>
		<li>chunktimeout - How long does the chunk need to be inactive,
			before considered timed out (seconds)</li>
		<li>Emailaddr - Email to send Notifications to.</li>
		<li>Emailerror - Email agent errors to the set email address.</li>
		<li>Emailhldone - Email when a hashlist is completed.</li>
		<li>Emailtaskdone - Email when a tasks is completed.</li>
		<li>fieldseparator - Default field separator for data
			import/export</li>
		<li>HashlistAlias - Identifier used to tell the client
		the name and location of the hashlist.</li>
		<li>statustimer - Default for how often should agent report its
			status during cracking (seconds)</li>
		<li>timefmt - Date/time format to display in admin (see PHP
			function date() for this)</li>
	</ul>
	You should also take your time to configure the Hashcat releases.
	Hashtopussy employs distribution mechanism to ensure that every agent will
	have the newest possible Hashcat release suitable for their GPU driver.
	The installation SQL script comes with pre-configured release pointing to
	the current version at the time of release, but as newer versions will
	be released, you will need to add them to your releases. Further info is
	explained in the Releases menu item documentation.
</div>
<h3>Users</h3>
<div class='alert alert-neutral'>
	Add remove and change user permissions:
	<ul>
		<li>One of the largest differences between hashtopus and hashtopussy
		is user accounts. These accounts allow you to set user privileges
		to specific users.</li>
		<li>View user (1): This user can only see their own account information and
		Tasks this includes task progress and number of cracks. 
		They cannot see plain text password cracks or any other information.</li>
		<li>Read only user (5): Has the same permissions as lower users (1) plus
		they can see Hashlists, Superhashlists, tasks, Chunk Activity and 
		plain text password cracks</li>
		<li>Normal User (20): Has the same permissions as lower users (1,5) plus
		access to agent data, Files, hashcat releases. User can create tasks, preconf tasks,
		supertasks, hashlists, and superhashlists.  User cannot create agents,
		hashcat releases, modify agents they do not own, or create other users</li>
		<li>Superuser (30): Has read/write on everything except creating other users or 
		modifying user accounts</li>
		<li>Admin (50): All hail our dark lord and master!</li>
	</ul>
</div>
<h3>Uploading files</h3>
<div class='alert alert-neutral'>
	If you are not new to cracking hashes, you probably have a nice collection of word lists and rules. 
	<br>If you want to use those files in cracking tasks, you need to add them to Global files section. 
	<br>This can be done three different ways and all of them are covered in Global files menu item documentation.
</div>
<h3>Pre-configured tasks</h3>
<div class='alert alert-neutral'>
	As you might have noticed, you often apply the same kinds of attacks against every hashlist you acquire.
	<br>It would be a waste of time to define it every time. That's why Hashtopussy has Pre-Configured tasks.
	<br>Pre-Configured tasks look like normal tasks but they are not directly attached to any hashlist.
	<br>Once you upload a new hashlist, you can select which of the Pre-Configured tasks you want to apply to it. 
	<br>Hashtopussy will then duplicate those tasks for that specific hashlist and execute them in the defined order (priority).
</div>
<hr>
<h1>Features documentation</h1>
<div class='alert alert-neutral'>
	This section documents each feature by its menu item. 
	<br>The features are sorted by chronological order, in which they are likely to be used.
</div>
<h3>Server configuration</h3>
<div class='alert alert-neutral'>
	Allows you to set configuration values for your server.
	<br>You also have a set of DB-cleaning tools in case you get yourself into some inconsistency trouble.
</div>
<h3>Hashcat releases</h3>
<div class='alert alert-neutral'>
	This section is now obsolete and needs to be changed.
	<br>This section contains list of defined Hashcat releases. 
	<br>Each release has numerous values that describe what to do with it.
	<br>There are separate options for NVidia cards and AMD cards because Hashcat is released in two separate archives as well.
	<br>Each release therefore contains URL to download on each platform. 
	<br>Column Common files contains list of files to extract regardless of CPU architecture or GPU brand.
	<br>These files will be extracted on every agent. Next column are Specific files.
	<br>There you can see different lists of files for 32/64 bit CPUs combined with NVidia/AMD brand, total of 4 combinations.
	<br>Next column is Root directory, which is simply the name of the Root directory inside the archive.
	<br>All files in previous columns are expected to be relative to the Root directory.
	<br>Following is the Required driver column.
	<bt>This specifies the minimal version of GPU driver the agent has to have installed in order to be given instruction to download this Hashcat version.
	<br>NVidia drivers are specified as five numbers, for example 33167 means driver v331.67, AMD drivers are represented by four numbers, where 1404 means Catalyst 14.4.
	<br>Last column gives you the opportunity to delete old releases.
	<br>If a release is still used by some agent, you won't be allowed to delete it.
</div>
<h3>New release</h3>
<div class='alert alert-neutral'>
	As the name suggests, this is the place to define new Hashcat releases.
	<br>Every time you open this form, it will be pre-filled by the data of the last release previous to it, as most of the fields barely change.
	<br>The URL has to be absolute. All files are space-separated.
</div>
<h3>Global files</h3>
<div class='alert alert-neutral'>
	Think of this as a file server. Every word list and rule set needs to be
	added to this list before you can use it in your tasks. You have three
	ways of adding files:
	<ul>
		<li><b>HTTP upload</b> The file will be uploaded from your browser.
		Suitable for smaller files because default server limits are not very
		generous.</li>
		<li><b>Import</b> The file will be moved from directory called 'import'
		you can create inside the web directory. Suitable for large files, you
		can copy them via FTP or locally and then simply import.</li>
		<li><b>URL download</b> The file will be downloaded from the URL
		specified. The download will read 128KB chunks and print progress to
		the screen every few seconds.</li>
	</ul>
	Because these files will be delivered to every agent who needs them for
	their current task, you can compress them using 7Zip to save bandwidth.
	However, you need to keep some basic rules: the file can't be in any
	subdirectory inside the archive and the algorithm needs to be LZMA (to
	be specific, it must be unpack-able by 7zr). Every time an agent will
	download a file ending with .7z, it will first extract it prior to
	starting the task.
	<br>
	You can mark any file as "Secret" using check-box in the column with a
	lock icon. This will allow only trusted agents to download the file.
	Agents not marked as trusted won't even see such task to begin with.
</div>
<h3>Pre-conf tasks</h3>
<div class='alert alert-neutral'>
	There are Three types of tasks in Hashtopussy. Regular ones, Supertasks
	and pre-configured tasks. They are actually the same thing with one
	difference: while regular task NEEDS to be assigned to specific
	hashlist, a pre-configured and supertasks do not. Pre-conf task and supertasks
	can't have any agents assigned or any chunks dispatched. It's sort of a mask for the
	regular tasks, once there are some hashes to crack. Unlike regular
	tasks, pre-configured and super tasks can be defined without having any actual
	hashes in the system. Once defined, you will be allowed to apply these
	tasks to every hashlist you upload to Hashtopussy.
	SuperTasks are groups of pre-conf tasks lets say for example you have 10 pre-conf
	tasks each brute forcing 1,2,3..10 digits respectively if you have these tasks 
	grouped together in a supertask all 10 tasks can be deployed with a single click.
	tasks can only be added to a supertask if they are first created as a pre-configured task
	<br>
	All of the fields are also in the regular tasks list, so they will be
	described there.
</div>
<h3>New task</h3>
<div class='alert alert-neutral'>
	In this form, you can define new task, should it be pre-configured or
	not. Every task needs to have a name (if you don't specify any it will
	be generated but as you will find out, it's REALLY a good idea to keep
	names organized once you have many of them) and a command line. This is
	not the actual final command line, it will be enriched with more
	parameters which is the reason you can't use them here (as the form
	informs you). An example of command line would be
	<code>-a 0 #HL# words.txt</code>
	, provided that you would check words.txt in the table on the right
	(read below).
	<br>
	Very important option is the hashlist selection. Choose an existing
	hashlist or a pre-configured task. Following are some tweaking
	parameters.
	<br>
	The chunk size instructs Hashtopussy, how big chunks should it dispatch to
	agents, time-wise. This means that more powerful agents will be given
	larger chunks of key-space compared to less powerful ones, but they
	should take about the same time. This is achieved by benchmarking the
	agents prior to giving them chunks.
	<br>
	Next option is the status timer. This defines, how often should an agent
	report to the server during task cracking.
	<br>
	Last check box sets if Hashtopussy should adjust agent's benchmark
	automatically according to the last chunk. This means that i.e. if the
	agent takes longer time than the defined chunk time, next time it will
	be given smaller chunk to meet the definition. However, this feature
	should only be enabled for attacks with "stable" speed, like mask
	attacks.
	<br>
	If you have already uploaded something into Global files, you see
	another table on the right with every file in the system. If you want to
	use any of those files for this task, check them. If you have compressed
	some files into 7Zip archive, check the archive the same way, but you will
	see that the file is added as "filename.???" hashtopus does not know the name
	of the file inside of the archive so you must use the file name inside the archive
	in the task command line.
</div>
<h3>Agent deployer</h3>
<div class='alert alert-neutral'>
	Since you have set up all things need to crack hashes, you need some
	computing power! The Agent deployer menu is just the place to start. On
	the top of the page, you see "Download agent" link. This is the direct,
	non-passworded link to download the current Hashtopussy agent exe.
	Download this executable on all machines intended for cracking hashes,
	regardless of their OS.
	<br>
	Once executed, the agent will ask for registration voucher. That's what
	is the form on the page for. You can generate as many vouchers as you
	want (and you can define your own text and not use the pre filled one).
	These vouchers are one-time tickets to allow agent registration. Once
	the registration is successful, the agent will receive connection token
	and will never ask for password unless you delete that token or delete
	the agent from the administration panel.
</div>
<h3>Agents</h3>
<div class='alert alert-neutral'>
	Assuming you have your agents registered, you will see them in this list
	along with lots of useful information:
	<ul>
		<li><b>Act</b> This little check box enabled/disables the agent. Should
		Hashcat error occur, agent will be deactivated automatically unless
		Ignore errors is enabled for it.</li>
		<li><b>Machine Name</b> This is the actual machine name.</li>
		<li><b>Owner</b> User name of the agent owner.</li>
		<li><b>OS</b> A little icon identifying Windows from Linux.</li>
		<li><b>CPU</b> Either 32 or 64 bit.</li>
		<li><b>GPU brand</b> Either NVidia or AMD.</li>
		<li><b>Driver</b> This tells you agent's driver version. Refer to
		releases' documentation for format explanation.</li>
		<li><b>GPUs</b> A shortened list of detected GPU cards. Hover mouse for
		full text.</li>
		<li><b>Hashcat</b> If not empty, tells you what release of hashcat has the
		agent downloaded.</li>
		<li><b>Last activity</b> Tells you what, when and from what IP has the
		agent done last.</li>
		<li><b>Assignment</b> Shows you and lets you change agent's current
		assignment.
		<br></li>
		<li><b>Action</b> Lets you delete the agent. If you will need it again, it
		will need to register using fresh voucher (see above).</li>
	</ul>
	Important thing is that agent ID and Name are click-able, which will get
	you to agent detail page. On this page, you can see all of the
	information from before plus some more.
	<br>
	You will also notice that GPU brand is changeable here, giving you the
	chance to correct possible bad decision or even complete lack of
	decision by Hashtopussy.
	<br>
	Don't miss the other configurable fields - you can define Hashcat
	parameters only applied to this agent. If you need things like --force,
	--workload-profile or --gpu-temp-disable only for some agents, this is
	the place to set them instead of the task command line. You can also
	edit Idle wait (the time the agent will wait for user inactivity before
	it starts cracking), Trust set-up (only trusted agents will be allowed to
	crack tasks with secret hashlist or files) and Error ignoring (agent
	will not be deactivated if an error occurs).
	<br>
	If there was already some activity by this agent, you can see uploaded
	errors and dispatched chunks down the page.
</div>
<h3>Hashlists</h3>
<div class='alert alert-neutral'>
	This is the storage of all your cracking targets. A hashlist, as the
	name suggests, is a list of hashes, even if there should be only one
	hash in it. In this table you can see all your hashlists, along with
	information how many hashes there are and how many of them are cracked.
	You can also see hash type and you have some options like deleting the
	hashlist or importing/exporting pre-cracked hashes. This option allows
	easy synchronizing between multiple Hashtopussy instances or even between
	off-line Hashcat instance and Hashtopussy. Be sure to set correct field
	separator in Server configuration.
	<br>
	The hashlist name and ID is click able and will get you to hashlist
	detail page. In there, you can see all of the info form Hashlist list as
	well as list of tasks cracking against this hashlist. Clicking on most
	of the hashes count will take you to view the actual hashes stated
	there.
	<br>
	Enabling Secret option will allow only trusted agents to crack the
	hashlist.
	<br>
	The option Generate word list will take all already cracked hashes, strip
	the $HEX[] format and save the file as a .txt in your Global files.
	<br>
	If you have some tasks pre-configured, you can see them in the list at the bottom.
	Checking any of them and clicking Create button will result
	in duplicating the pre-conf tasks and turning the copies into regular
	tasks attached to this hashlist. The priority of these new tasks will be
	sum of the maximum priority of the regular tasks and the priority of
	their pre-conf originals.
</div>
<h3>New hashlist</h3>
<div class='alert alert-neutral'>
	With all that computing power, you might as well start cracking
	something. The New hashlist option gives you what you need. Again, every
	hashlist needs to have a name (this one here is mandatory, it won't be
	generated if omitted). You also need to specify a hash type in a number
	format, the same you would give to Hashcat with -m. Hashlist format
	specifies whether the hashlist is a text file with many hashes, HCCAP
	file with network captures or binary hashlist (used for TrueCrypt 512B
	headers but not limited to that size).
	<br>
	Bellow you have an option to select where to get the hashes from. You
	are already familiar with Upload, Import and URL download from Global
	files section. The only remaining is the Paste, which will simply show
	text box allowing you to copy-paste hashes in there.
	<br>
	Please note that creating text-based hashlists takes some time. For
	multi-million hashes, that will go into minutes and that's on well
	configured MySQL server and sorted list. If you miss-configure your MySQL
	server and don't sort your hashlist (that's really a MUST), you might as
	well end up waiting several hours. This is MySQL limitation and there is
	really nothing I can do about it. Having FILE privilege for your MySQL
	user is very recommended, because Hashtopussy can then use LOAD DATA
	command. If it fails for whatever reason, it starts to INSERT the hashes
	one by one inside a transaction, which is several times slower. If you 
	are having issues with LOAD DATA from file have a look at your web-root permissions
	and	'apparmor' Configuration.
</div>
<h3>New superhashlist</h3>
<div class='alert alert-neutral'>
	Sometimes you find yourself in a situation where you have multiple
	hashlists of the same hash type. Naturally, the fastest way is to merge
	them as one and crack all at once. But what if they are from different
	sources and the results should never be mixed? The superhashlist is the
	feature to solve this problem. Once you have created some hashlists, you
	can create a superhashlist over them and use it as a regular hashlist in
	your tasks. However, the cracks will be kept in the original hashlists,
	so you will see exactly which plain text belongs where. Should one hash
	be contained in more hashlists, it will be cracked in all of them at
	once.
	<br>
	However, if any of the contained hashlists is marked as secret, hashes
	from this hashlist will not be given to untrusted agents to crack.
	Should the superhashlist itself be marked as secret, no task cracking
	this superhashlist will be given to untrusted agent in the first place.
</div>
<h3>Tasks</h3>
<div class='alert alert-neutral'>
	Let's assume you have created a hashlist and either assigned a bunch of
	pre-conf tasks to it or simply created new tasks from scratch, just for
	this hashlist. You can see them in this very list. The information shown
	to you are:
	<ul>
		<li><b>Name</b> Name of the task that you specified or that was generated
		(hover mouse to get task command line pop-up).</li>
		<li><b>Hashlist</b> Name of the (super)hashlist the task is cracking.</li>
		<li><b>Chunks</b> Number of dispatched chunks and how long are they
		configured to take.</li>
		<li><b>Dispatched</b> How much of key space was cut into existing chunks.</li>
		<li><b>Searched</b> How much of key space was actually searched in these
		chunks.</li>
		<li><b>Cracked</b> How many hashes were cracked in this task. If clicked,
		will take you to the actual list of those hashes.</li>
		<li><b>Agents</b> Number of agents currently assigned to this task.</li>
		<li><b>Files</b> Number of global files attached to this task.</li>
		<li><b>Priority</b> Here you can see or change the priority of each task.
		Tasks with the highest priority are cracked
		<br>first. If you have an agent assigned to a task and you will
		prioritize a new task over the current one,
		<br>as soon as the agents will finish their current chunk they
		will move to the new task and get back
		<br>to the previous one once they finish cracking the new one.
		<br> To make it simple, every time an agent asks for new chunk, it
		will be directed to the most prioritized task.
		<br> A lock icon in any column marks secret data.</li>
		<li><b>Action</b> As in every page, an option to delete the task.</li>
	</ul>
	Clicking on task name will take you to task detail, which is one of the
	most important screens in the system. You can see all the information
	about the task from the task list plus estimated and spent time, and
	current cracking speed. You can also see the full command line.
	<br>
	Notice that some options are changeable - you can redefine chunk size
	and after you do that, all agents' benchmarks will be recalculated to
	match it.
	<br>
	Under the main table is a visual representation of a task. This picture
	shows the exact chunk spread amongst the key space including if anything
	was cracked in each chunk (green filling) or if there were any problems
	and the chunk was trimmed (red border).
	<br>
	Below is the list of attached files (click able to detail in Global files
	section).
	<br>
	The table under it shows information about agents assigned to this task:
	<ul>
		<li><b>Name</b> Name of agent that will link you to agent detail.</li>
		<li><b>Benchmark</b> How big chunk will be dispatched to this agent with
		the ability to set auto-adjusting of this size.
		<br>If you have auto-adjusting disabled, feel free to modify this
		value as high performance systems require larger chunks to fully
		utilize all the GPU power.</li>
		<li><b>Speed</b> Current cracking speed (only on active agents)</li>
		<li><b>Key space searched</b> What part of the total key space has the agent
		searched.
		<br>If you plan to reward your agents for their work, this is the
		relevant info.</li>
		<li><b>Time spent</b> Also good way to reward your agents, this shows how
		much actual time has the agent spent on this task.</li>
		<li><b>Cracked</b> A simple number showing how many hashes has the agent
		cracked.</li>
		<li><b>Last activity</b> Tells you exactly when was agent's last activity
		on this tasks.</li>
		<li><b>Action</b> Lets you unassign the agent from this task. Keep in mind
		that if it's the highest priority task, the agent will return to it
		just after finishing its chunk.</li>
		<li>Show All Assignments is an option that allows you to see stats on a task
		without clients currently assigned. If a client spent time assigned to the task
		its data should be seen such as key space searched and time spent.</li>
	</ul>
	Last and also very informative table shows the actual chunks that were
	dispatched in this task. You see numerous values there:
	<ul>
		<li><b>Start</b> Where exactly in the key space does this chunk start.</li>
		<li><b>Length</b> How long the chunk is, key space-wise</li>
		<li><b>Checkpoint</b> If the agent crashed, from where would the chunk
		have to be restarted.</li>
		<li><b>Progress</b> Real progress in that chunk, regardless of checkpoint.</li>
		<li><b>Agent</b> Self-explanatory.</li>
		<li><b>Dispatch time</b> When was the task given to the agent.</li>
		<li><b>Last activity</b> When was the last time agent reported activity on
		this chunk.</li>
		<li><b>Time spent</b> The difference between two previous values.</li>
		<li><b>State</b> Mimics Hashcat's state info plus adds a new option:
		Trimmed (means the chunk was dead, cut and the rest reassigned to
		someone else)</li>
		<li><b>Cracked</b> How many hashes were cracked in this chunk. If clicked,
		will take you to the actual list of those hashes.</li>
		<li><b>Action</b> If the chunk is inactive long enough (configured in
		server configuration), lets you reset its progress and checkpoint to
		zero.
		<br> Don't to this to chunks in progress, or you will create
		redundant work.</li>
	</ul>
</div>
<h3>Chunk activity</h3>
<div class='alert alert-neutral'>
	This is the same table as in task or agent details, but shows chunks for
	ALL tasks and ALL agents.
	<br>
	A good place to monitor overall cracking activity.
</div>
<hr>
<h1>Command line</h1>
<div class='alert alert-neutral'>
	The Hashtopussy agent (client) has several command line parameters you can use to
	alter the behaviour of the agent. Those parameters are invoked as
	standalone words without prefixes like dash, etc.
	<br>
	<ul>
		<li><b>debug</b>
		<br>Invoking this parameter will force Hashtopussy to print all Hashcat output to screen as well as invoked Hashcat command lines.
		<br>Use this if you are suspecting bad parameters passed to Hashcat or Hashcat outputting garbage.</li>
		<li><b>eventmode</b> In the Event mode, Hashtopussy won't start cracking immediately. 
		<br>Instead, it will create file event_ready and wait for you to delete it.
		<br> Once you delete it, it will start cracking and will continue to crack as long as there are unfinished tasks.
		<br> When all work is completed, Hashtopussy will create file event_idle and wait for more work again.
		<br>You can use these files to wrap your own scripts around Hashtopussy to, for example, 
		<br>use your GPU on other purposes in the meantime when there is nothing to crack.</li>
		<li><b>nocheck</b>
		<br>This parameter assumes you know what you are doing make sure you have a working environment before running nocheck
		<br>This parameter disables driver version checking and also disables hashcat downloading.
		<br>You need to manually download and extract hashcat into the hashcat directory.
		<br>This enables hashtopussy to support HC3.0 and CPU only machines if you are having issues try nocheck!
	</ul>
</div>
